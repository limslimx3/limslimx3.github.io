---
title: "[Spring] 1.스프링 핵심원리"

toc: true
toc_sticky: true

categories:
   - Spring
tags:
   - Spring

last_modified_at: 2024-02-24T22:00:00


---

# 스프링 핵심원리

> 여러 스프링의 부가적인 기능들을 알아보기에 앞서 스프링의 기반이 되는 핵심원리에 대해 알아보자

![core_principle1]({{site.url}}{{site.baseurl}}/assets/images/spring/core_principle/1.png)

## 배경지식

> 스프링은 결국 ```Java``` 즉, 객체지향 언어의 특징을 최대한 살릴수 있도록 도와주는 프레임워크이다

### 좋은 객체지향 프로그래밍은 무엇일까?

- 객체지향 프로그래밍은 추상화, 캡슐화, 상속, 다형성 등 다양한 특징을 지니지만 그 중에서도 가장 중요한 것을 하나 꼽으라면 **다형성**이다
- 그렇다면 다형성이란 무엇일까?

![core_principle2]({{site.url}}{{site.baseurl}}/assets/images/spring/core_principle/2.png)

- 역할과 구현으로 나눠 위 예시를 통해 살펴보도록 하자
- 어떤 운전자가 K3를 타다가 어느 정도 돈이 모여 테슬라 모델3를 구입하였다고 가정해보자
- K3와 테슬라 모델3 모두 자동차이기 때문에 바뀌었다고 해서 운전법이 변하지 않는다. 즉, 운전자에게 영향을 주지 않는다
- 이를 프로그래밍적으로 설명하면 클라이언트가 interface에만 의존하도록 설정한다면 이후 변경사항들이 생겨도 해당 interface만을 구현하도록 하면 되는 식이다
- 클라이언트는 interface를 의존하기만 하고 구현체의 내부 구조를 몰라도 된다. 또한, 구현체를 바꾼다고 해서 영향을 받지도 않는다
- 즉, **<u>interface를 우선적으로 만들고 이를 구현하는 클래스를 만들어 사용</u>**한다



간단한 그림을 통해 좀 더 살펴보자

![core_principle3]({{site.url}}{{site.baseurl}}/assets/images/spring/core_principle/3.png)

- ```MemberService```는 ```MemberRepository```라는 interface를 의존하는 형태이다
- ```MemoryMemberRepository```와 ```JdbcMemberRepository```는 모두 ```MemberRepository```를 구현하는 클래스이다
- ```MemberService```는 언제든지 ```JdbcMemberRepository```와 ```MemberRepository``` 둘 중에 하나를 선택하여 바꿀 수 있다
- 즉, **<u>인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다</u>**는 것이 다형성의 핵심이다
- 결국 모든 것의 기반이 되는 **<u>인터페이스를 안정적으로 잘 설계</u>**하는 것이 가장 중요하다



### SOLID

> 좋은 객체지향 설계 5가지 원칙의 앞글자를 따서 SOLID라고 부른다

1. SRP 단일 책임 원칙

   - 하나의 클래스는 하나의 책임만 가져야 한다
   - 추후에 변경할 일이 생겼을때 파급효과가 적다면 이 원칙을 잘 따른 것이다

2. **OCP 개방-폐쇄 원칙**

   - **<u>확장에는 열려있으나 변경에는 닫혀</u>**있어야 한다

   - 위에서 설명한 다형성을 생각해보면 확장을 위해 새로운 구현 클래스를 만들어도 interface를 구현하기만 한다면 기존 코드에서 변경되는 부분은 없다

   - 사실 Java의 다형성만으로는 OCP를 완벽히 지키기 어렵지만 Spring을 이용한다면 확실히 OCP를 지킬 수 있다

     ``` java
     public class HelloService {
     //    HelloRepository repository = new MemoryHelloRepository();
         HelloRepository repository = new JdbcHelloRepository();
     }
     ```

     - 위의 코드처럼 ```MemoryHelloRepository```를 사용하다가 ```JdbcHelloRepository```로 변경할 경우 코드 변경이 불가피하다
     - 하지만 Spring의 도움을 받는다면 ```HelloService```의 코드 변경 없이 ```HelloRepository```의 구현체 변경이 가능하다

3. LSP 리스코프 치환 원칙

   - 인터페이스를 구현한 객체는 인터페이스의 기능을 제대로 수행해야 한다

4. ISP 인터페이스 분리 원칙

   - 하나의 인터페이스에 여러가지 기능을 담기보단 각각의 기능을 담는 인터페이스를 여러개 만들어야 한다

5. **DIP 의존관계 역전 원칙**

   - **<u>구현 클래스에 의존하는 것이 아니라 인터페이스에 의존</u>**해야 한다
   - 클라이언트 코드는 인터페이스에 대해서만 알면 되지 구체적인 구현체의 내부구조에 대해서 알 필요가 없게 설계해야 한다
   - OCP 파트에서 예시로 든 코드는 사실 ```HelloService```가 인터페이스가 아닌 구현 클래스에 의존하기 때문에 DIP 원칙에 위배된다



=> **결국 다형성만으로는 OCP, DIP를 지킬 수 없고 여기서 등장한 것이 바로 스프링이다**

 

## 1. 스프링 핵심원리

> 코드의 변화과정을 살펴보며 스프링의 핵심원리인 IoC와 DI에 대해 알아보자

![core_principle4]({{site.url}}{{site.baseurl}}/assets/images/spring/core_principle/4.png)

- 위 구조도를 코드로 작성하면 아래와 같다

``` java
public interface MemberRepository {
    void save(Member member);
    Member findById(Long memberId);
}
```

``` java
public interface MemberService {
    void join(Member member);
    Member findMember(Long memberId);
}
```

``` java
public class MemoryMemberRepository implements MemberRepository{

    private static Map<Long, Member> store = new HashMap<>();

    @Override
    public void save(Member member) {
        store.put(member.getId(), member);
    }

    @Override
    public Member findById(Long memberId) {
        return store.get(memberId);
    }
}
```

``` java
public class MemberServiceImpl implements MemberService{

    private MemberRepository memberRepository = new MemoryMemberRepository();

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}

```

- ```MemberServiceImpl```이 ```MemberRepository```라는 인터페이스가 아닌 ```MemoryMemberRepository```라는 구현 클래스를 의존하는 형태이다
- ```MemoryMemberRepository```라는 클래스를 ```MemberServiceImpl```에서 직접 생성하여 사용하므로 이런 경우 개발자에게 제어권이 있다고 말한다

이번에는 스프링 코드를 살펴보자

다른 코드들은 동일하지만 ```MemberServiceImpl```에 변화가 발생하고 ```AppConfig```라는 클래스를 새로 생성한다

``` java
public class MemberServiceImpl implements MemberService{

    private final MemberRepository memberRepository;

    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```

``` java
@Configuration
public class AppConfig {

    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    @Bean
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }
}
```

- ```MemberServiceImpl```의 코드를 살펴보면 인터페이스에만 의존하고 생성자를 통해 해당 필드값을 넣어줌을 확인할 수 있다
  - 이를 생성자를 통한 의존관계 주입이라고 부르는데 자세한건 아래에서 알아보기로 하자
- ```AppConfig```라는 설정 클래스는 빈을 만들어 스프링 컨테이너에 담는 역할을 한다
  - 빈은 간단히 말해 개발자가 비즈니스 로직에 필요하여 작성한 클래스 객체를 의미한다
  - 스프링 컨테이너는 간단히 말해 이 빈들의 모든 것을 관리해주는 역할을 한다
- ```@Configuration```은 스프링 빈 설정 정보들을 담고 있으므로 스프링 실행 시에 하위 ```@Bean```이 붙은  메서드 이름으로 빈을 등록시키라고 명령을 내린다
- 위의 코드는 결국 비즈니스 로직은 비즈니스 관련 업무를 처리하도록 하고 그 과정에서 필요한 객체들의 생성은 설정 파일에서 따로 관리한다
  - ```MemberServiceImpl```은 의존관계에 있는 ```MemberRepository```로 어떤 구체 클래스가 주입될지 모르는 상황이다

### 1-1. IoC

- Inversion of Control이라고 해서 제어의 역전을 의미한다
- 위에서 스프링을 이용하기 전 기존 코드에서는 제어권이 개발자에게 있다
- 스프링을 이용한 코드에서는 개발자가 해당 클래스에서 의존관계에 있는 클래스를 직접 생성하지 않는다
  - ```AppConfig```라는 설정 파일을 이용하여 필요한 빈들을 등록하기만 스프링이 자동으로 런타임 시점에 알맞은 클래스를 생성자 주입해준다
  - 이는 제어권이 스프링 쪽에 넘어간 상황으로 제어의 역전이 발생했다고 얘기한다
- 참고로 라이브러리와 프레임워크의 차이가 여기에 있다
  - 라이브러리: 개발자가 만든 코드가 직접  제어의 흐름을 담당
  - 프레임워크: 프레임워크에게 제어권이 있어 빈만 등록한다면 프레임워크가 자체 사이클에 따라 제어

### 1-2. DI

- 위의 스프링을 사용한 코드에서 ```MemberServiceImpl```은 ```MemberRepository```를 의존할 뿐 실제로 어떤 구체 클래스가 들어올지 모른다
- 실제 런타임 시점에 스프링 컨테이너에 의해 해당 인터페이스를 구현한 ```MemoryMemberRepository```가 생성자를 통해 주입되는데 이를 의존관계 주입(Dependency Injection)이라고 한다

### 1-3. 스프링 컨테이너와 빈

- 위와 같이 ```AppConfig```를 작성하고 해당 클래스를 ```@Configuration```, 하위 메서드를 ```@Bean```으로 적어주면 ```ApplicationContext```라는 스프링 컨테이너를 통해 빈들에 접근하여 사용가능하다

- 참고로 **<u>스프링 컨테이너에 빈 등록 시에는 반드시 다른 이름</u>**이어야 한다

- ```ApplicationContext```를 통해 ```memberService```라는 이름의 빈을 가져오는 실제 코드는 아래와 같다

  ``` java
  ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
  MemberService memberService = ac.getBean("memberService", MemberService.class);
  ```

  - 여기서 ```ApplicationContext```라는 인터페이스를 구현한 ```AnnotationConfigApplicationContext```를 사용하는 이유는 우리가 만든 ```AppConfig``` 설정 파일이 어노테이션 기반으로 작동하기 때문이다
  - ```ApplicationContext```라는 스프링 컨테이너로 ```AppConfig```라는 구성정보가 든 파일을 넘긴다
  - ```getBean()``` 메서드는 첫번째 파라미터로 빈이름이, 두번째 파라미터로 타입을 받는다
    - 참고로 ```getBean()``` 메서드의 파라미터로 ```Object``` 타입을 넣는다면 모든 빈을 조회한다

- 스프링 컨테이너는 크게 ```BeanFactory```와 ```ApplicationContext``` 2가지로 나뉜다

  ![core_principle5]({{site.url}}{{site.baseurl}}/assets/images/spring/core_principle/5.png)

  1. BeanFactory

     - 스프링 컨테이너의 최상위 인터페이스

     - 스프링의 기본적인 빈 조회 및 관리를 담당한다
       - 대표적으로 ```getBean()``` 메서드를 제공한다

  2. **ApplicationContext**
     - 기본 기능을 제공하기 위한 ```BeanFactory```와 부가기능을 제공하기 위한 ```EnvironmentCapable```, ```MessageSource```, ```ApplicationEventPublisher```, ```ResourcePatternResolver```를 상속받은 인터페이스
       - ```EnvironmentCapable```: 실무에서 로컬, 개발, 운영 등을 분류하여 처리하는 기능을 제공한다
       - ```MessageSource```: 메세징 및 국제화 기능을 제공한다
       - ```ApplicationEventPublisher```: 등록된 리스너에게 이벤트를 발행하는 기능을 제공한다
       - ```ResourcePatternResolver```: 클래스패스나 파일시스템 등의 리소스를 조회하는 기능을 제공한다

  - ```BeanFactory```는 거의 사용하지 않고 대부분 ```ApplicationContext```를 사용한다

- 스프링은 자바 코드, XML, Groovy 등등 다양한 형식의 설정 정보를 읽어들일 수 있도록 ```ApplicationContext```를 실제 구현한 클래스들을 제공한다

  ![core_principle6]({{site.url}}{{site.baseurl}}/assets/images/spring/core_principle/6.png)

  - 위에서 사용한 ```AnnotationConfigApplicationContext```는 자바 코드로 된 설정 정보를 받아들인다

  - ```GenericXmlApplicationContext```는 XML로 된 설정 정보를 받아들인다

    - 참고로 XML로 설정된 설정 파일 예시는 아래와 같다

      ``` xml
      <?xml version="1.0" encoding="UTF-8"?>
      <beans xmlns="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
      
          <!-- 빈 등록 시작 -->
          <!-- 생성자 주입 위해 constructor-arg 태그 사용 -->
          <bean id="memberService" class="springcore.core.member.MemberServiceImpl">
              <constructor-arg name="memberRepository" ref="memberRepository" />
          </bean>
      
          <bean id="memberRepository" class="springcore.core.member.MemoryMemberRepository" />
      
          <bean id="discountPolicy" class="springcore.core.discount.RateDiscountPolicy" />
      
          <bean id="orderService" class="springcore.core.order.OrderServiceImpl">
              <constructor-arg name="memberRepository" ref="memberRepository" />
              <constructor-arg name="discountPolicy" ref="discountPolicy" />
          </bean>
          <!-- 빈 등록 마무리 -->
      </beans>
      ```

  - 해당 클래스를 생성하면서 파라미터값으로 설정 정보가 들어있는 파일을 넘겨주면 된다
